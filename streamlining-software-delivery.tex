\documentclass[english]{tktltiki2}

% -- Packages --

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% -- Language --

\usepackage[fixlanguage]{babelbib}

% Add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}

% -- tktltiki2 options --

\title{Advances in Streamlining Software Delivery on the Web and its Relations to Embedded Systems}
\author{Kasper Hirvikoski}
\date{\today}
\level{Master’s thesis}
\abstract{Abstract.}

\keywords{keyword}
\classification{}

\begin{document}

% -- Front matter --

\frontmatter

\maketitle
\makeabstract

\tableofcontents

% -- Main matter --

\mainmatter

% -- Introduction --

\section{Introduction}

Software delivery on the web has over the years evolved into a rather established process. A software is developed iteratively through multiple stages, which ensure the user’s requirements and the quality of the product or service. These stages form what is called the deployment pipeline~\cite{Fow06, HF11, Fow13a, Fow13b}.

The deployment pipeline nowadays usually consists of at least three stages: development, staging and production. Organisations alter these stages depending on their size and needs. Using modern iterative and incremental processes, a software is developed feature by feature by iterating through these stages. Development starts in the development stage where developers build the feature requested by the customer or user. The feature is then tested in the staging phase, which represents the production setting. When the feature has been validated, it is then deployed to production. If necessary, each stage can be repeated until the feature is accepted. The stages are short and features are deployed frequently — in some cases even multiple times a day~\cite{OR11, Sny13, Rub14}.

Software engineering consists of various different processes and practises for ensuring the quality of the product or service — nowadays more or less based on Agile and Lean ideologies and practises~\cite{BBB01, Fow05, Mon12}. At the low level, developers use source code management to keep track of changes to the software and to collaborate with other team members. To reinforce that the features work as intended, developers write automated test cases. Teams can also use more social methods — such as reviewing each other’s code — to validate the implementations. These practises form the basis for Continuous Integration and Continuous Deployment~\cite{Fow06, HF11, Fow13a, Fow13b}. Software changes are frequently integrated, tested and deployed — automatically in each stage. The first two form Continuous Integration and the latter Continuous Deployment. If any stage fails, the process starts from the beginning.

The web enables the use of the deployment pipeline and its practises in an unprecedented way~\cite{KLS09}. Due to the distributed nature of the web, software can be deployed as needed and the user always sees the newest version without the need of any interaction. This eases the use of many cutting-edge methods~\cite{KLS09}. Deploying software as needed has allowed developers to experiment with different implementations of a feature. These changes can affect anything from a more optimised algorithm to something more user-faced, such as improvements to the user experience of a product~\cite{KLS09}. These practises have started to formalise as Continuous Experimentation~\cite{FGM14}.

Not all software can be developed easily this way. Many embedded systems, which have a dedicated function within a larger mechanical or electrical system, require hardware to accompany the software. This presents a variety of challenges to overcome. Hardware can require thorough planning and iterating can take time. Contexts such as cross-platform support, robotics, aerospace and other embedded systems pose interesting cases. Many of these contexts can at a glance seem regarded as models for more traditional sequential software engineering processes with heavy planning, documentation and long development phases. However, even NASA’s earlier missions have iterated on the successes and failures of previous ones. Even though it can be more difficult, hardware can be build and tested iteratively with new approaches such as prototyping and 3D-printing.

This raises an interesting research topic — \emph{presenting the advances in streamlining software delivery on the web and relating its practises and their advantages and challenges to embedded systems}. Using case studies to identify which practises are used, how they could be improved and how new practises could be incorporated to these settings.

The approach of my thesis is to identify how modern software development methods, such as Agile and Lean, suit embedded settings and if and how they have been adapted to these environments. Moreover, the aim is to identify which modern Continuous Integration, Delivery and Experimentation practises are used, how they could be improved and how new practises could be incorporated to more embedded settings. Can we determine how they compare to web practises?

The hypothesis is that there should be no reason why these practises could not be successfully used and cleverly adapted to hardware settings.

My research method for this thesis was reviewing the current practises in literature and industry. I also conducted several interviews with the industry working on leading embedded systems to get a view on if and how the deployment pipeline has changed the development of hardware related products.

% -- Software Delivery --

\section{Software Delivery}

Software delivery has changed notably in the past few decades. It was not until 1968, when the term software engineering was introduced by the NATO Science Committee~\cite{NR69}. By that time, it was considered that software development had drifted into a crisis, where a long gap was present with the objectives and results with software. Additionally, it was getting increasingly difficult to plan the cost of software projects. There was a collective effort to establish a more formalised method, similar to traditional engineering, for software delivery. It was considered necessary that the foundation for delivering software should be more theoretical with laid principles and practises. By 1969, the term software engineering had become well-established~\cite{BR70}.

Software development processes began to form. In 1970, Winston W. Royce published a paper that described a formal approach for sequentially developing a software~\cite{Roy70}. It was only later named as the Waterfall-model. The process consisted of seven phases that should be carried after the previous had been reviewed and verified. The process began by planning the requirements for the entire software, then designing the architecture, followed by implementing the plan, verifying the result was according to the plan and finally maintaining the product. Each phase was documented thoroughly. However, Royce presented the model as a flawed, non-working model~\cite{Roy70}. If any of the steps failed, serious reconsideration of the plan might be necessary. Therefore sequentially following the phases in order would not produce what was intended and inevitably previous phases would need to be redone. Nevertheless, this was overlooked and the Waterfall-model became the dominant software development process at that time.

Waterfall-oriented models were heavyweight. The Waterfall-model was criticised as heavily controlled, documentation-oriented, micromanaged and over-incremental. More lightweight iterative processes were proposed as opponents for incremental software development in the later half of the 20th century. Fast-forward to 2001, when a group of software developers met to discuss new lightweight development principles. As the result of these discussions, a manifesto for Agile software development was published~\cite{BBB01}. They proposed four principles for Agile software development: focusing on individuals and interactions over processes and tools, focusing on working software over comprehensive documentation, focusing on customer collaboration over contract negotiation and responding to change over following a plan. They never dismissed the value of the latter, but considered the former more valuable. Iterative processes started to gain traction. Software development was considered as an ongoing process, where a product should be build feature-by-feature, iteratively going through the development phases. Instead of planning, designing and implementing the whole software incrementally, the software should be build iteratively by repeating all of the steps for each feature. Hence, any issue or miss-communication could be discovered early and fixed accordingly.

\subsection{Adapting to Requirements}

Adapting to requirements.

\subsection{Ensuring Quality}

Ensuring quality.

\subsection{Processes and Practises}

Processes and practises.

\subsection{From Agile to Lean}

From Agile to Lean.

% -- Deployment Pipeline --

\section{Deployment Pipeline}

Deployment pipeline.

\subsection{Development}

Development.

\subsection{Staging}

Staging.

\subsection{Production}

Production.

% -- Using Web as a Platform --

\section{Using Web as a Platform}

Using Web as a platform.

\subsection{Continuous Integration}

Continuous Integration.

\subsection{Continuous Deployment}

Continuous Deployment.

\subsection{Continuous Experimentation}

Continuous Experimentation.

% -- Towards Embedded Systems --

\section{Towards Embedded Systems}

Towards embedded systems.

\subsection{Using Hardware as a Platform}

Using hardware as a platform.

\subsection{Adapting for Deployment Pipeline}

Adapting for deployment pipeline.

% -- Example Case --

\section{Example Case}

Example case.

% -- Conclusions --

\section{Conclusions}

Conclusions.

% -- References --

\bibliographystyle{babalpha-lf}
\bibliography{references}

\end{document}
