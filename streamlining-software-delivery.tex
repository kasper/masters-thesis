\documentclass[english]{tktltiki2}

% -- Packages --

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% -- Language --

\usepackage[fixlanguage]{babelbib}

% Add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}

% -- tktltiki2 options --

\title{Advances in Streamlining Software Delivery on the Web and its Relations to Embedded Systems}
\author{Kasper Hirvikoski}
\date{\today}
\level{Master’s thesis}
\abstract{Abstract.}

\keywords{keyword}
\classification{}

\begin{document}

% -- Front matter --

\frontmatter

\maketitle
\makeabstract

\tableofcontents

% -- Main matter --

\mainmatter

% -- Introduction --

\section{Introduction}

Software delivery on the web has over the years evolved into a rather established process. A software is developed iteratively through multiple stages, which ensure the user’s requirements and the quality of the product or service. These stages form what is called the deployment pipeline~\cite{Fow06, HF11, Fow13a, Fow13b}.

The deployment pipeline nowadays usually consists of at least three stages: development, staging and production. Organisations alter these stages depending on their size and needs. Using modern iterative and incremental processes, a software is developed feature by feature by iterating through these stages. Development starts in the development stage where developers build the feature requested by the customer or user. The feature is then tested in the staging phase, which represents the production setting. When the feature has been validated, it is then deployed to production. If necessary, each stage can be repeated until the feature is accepted. The stages are short and features are deployed frequently — in some cases even multiple times a day~\cite{OR11, Sny13, Rub14}.

Software engineering consists of various different processes and practises for ensuring the quality of the product or service — nowadays more or less based on Agile and Lean ideologies and practises~\cite{BBB01, Fow05, Mon12}. At the low level, developers use source code management to keep track of changes to the software and to collaborate with other team members. To reinforce that the features work as intended, developers write automated test cases. Teams can also use more social methods — such as reviewing each other’s code — to validate the implementations. These practises form the basis for Continuous Integration and Continuous Deployment~\cite{Fow06, HF11, Fow13a, Fow13b}. Software changes are frequently integrated, tested and deployed — automatically in each stage. The first two form Continuous Integration and the latter Continuous Deployment. If any stage fails, the process starts from the beginning.

The web enables the use of the deployment pipeline and its practises in an unprecedented way~\cite{KLS09}. Due to the distributed nature of the web, software can be deployed as needed and the user always sees the newest version without the need of any interaction. This eases the use of many cutting-edge methods~\cite{KLS09}.

Not all software can be developed easily this way. Many embedded systems, which have a dedicated function within a larger mechanical or electrical system, require hardware to accompany the software. This presents a variety of challenges to overcome. Hardware can require thorough planning and iterating can take time. Contexts such as cross-platform support, robotics, aerospace and other embedded systems pose interesting cases. Many of these contexts can at a glance seem regarded as models for more traditional sequential software engineering processes with heavy planning, documentation and long development phases. However, even NASA’s earlier missions have iterated on the successes and failures of previous ones. Even though it can be more difficult, hardware can be build and tested iteratively with new approaches such as prototyping and 3D-printing.

This raises an interesting research topic — \emph{presenting the advances in streamlining software delivery on the web and relating its practises and their advantages and challenges to embedded systems}. Using case studies to identify which practises are used, how they could be improved and how new practises could be incorporated to these settings.

% -- Approach --

\section{Approach}

Approach.

\subsection{Research Method}

Research method.

\subsection{Case Studies}

Case studies.

% -- Software Delivery --

\section{Software Delivery}

Software delivery.

\subsection{Adapting to Requirements}

Adapting to requirements.

\subsection{Ensuring Quality}

Ensuring quality.

\subsection{Processes and Practises}

Processes and practises.

\subsection{From Agile to Lean}

From Agile to Lean.

% -- Deployment Pipeline --

\section{Deployment Pipeline}

Deployment pipeline.

\subsection{Development}

Development.

\subsection{Staging}

Staging.

\subsection{Production}

Production.

% -- Using Web as a Platform --

\section{Using Web as a Platform}

Using Web as a platform.

\subsection{Continuous Integration}

Continuous Integration.

\subsection{Continuous Deployment}

Continuous Deployment.

\subsection{Continuous Experimentation}

Continuous Experimentation.

% -- Towards Embedded Systems --

\section{Towards Embedded Systems}

Towards embedded systems.

\subsection{Using Hardware as a Platform}

Using hardware as a platform.

\subsection{Adapting for Deployment Pipeline}

Adapting for deployment pipeline.

% -- Case --

\section{Case}

Case.

% -- Conclusions --

\section{Conclusions}

Conclusions.

% -- References --

\bibliographystyle{babalpha-lf}
\bibliography{references}

\end{document}
